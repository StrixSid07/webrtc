<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>WebRTC Host/Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body class="bg-gray-100 text-gray-900">
    <div class="max-w-4xl mx-auto p-6">
      <h1 class="text-3xl font-bold text-center mb-6">WebRTC Host/Viewer</h1>

      <div
        class="flex flex-col md:flex-row items-center justify-center gap-4 mb-4"
      >
        <input
          id="roomInput"
          type="text"
          placeholder="Room ID"
          class="border rounded px-4 py-2 w-full md:w-64"
        />
        <button
          onclick="start(true)"
          class="bg-blue-600 text-white px-4 py-2 rounded"
        >
          Start as Host
        </button>
        <button
          onclick="start(false)"
          class="bg-green-600 text-white px-4 py-2 rounded"
        >
          Start as Viewer
        </button>
        <button
          id="stopBtn"
          onclick="stopStream()"
          class="bg-red-600 text-white px-4 py-2 rounded hidden"
        >
          Stop Host
        </button>
      </div>

      <p id="status" class="text-center text-sm text-gray-600 mb-4"></p>

      <div class="grid md:grid-cols-2 gap-4">
        <div>
          <h2 class="font-semibold">Local Video (You)</h2>
          <video
            id="localVideo"
            autoplay
            muted
            playsinline
            class="rounded shadow w-full"
          ></video>
        </div>
        <div>
          <h2 class="font-semibold">Remote Video (Peer)</h2>
          <video
            id="remoteVideo"
            autoplay
            playsinline
            class="rounded shadow w-full"
          ></video>
        </div>
      </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      const socket = io();
      let peerConnection;
      let isHost = false;
      let localStream;
      let remoteSocketId;
      let pendingCandidates = [];

      const config = {
        iceServers: [
          { urls: "stun:stun.l.google.com:19302" },
          // You can add TURN servers here for better NAT traversal:
          // { urls: 'turn:your.turn.server:3478', username: 'user', credential: 'pass' },
        ],
      };

      const localVideo = document.getElementById("localVideo");
      const remoteVideo = document.getElementById("remoteVideo");
      const status = document.getElementById("status");
      const stopBtn = document.getElementById("stopBtn");

      function setStatus(msg) {
        status.textContent = msg;
      }

      async function start(host) {
        isHost = host;
        const roomId = document.getElementById("roomInput").value.trim();
        if (!roomId) {
          alert("Enter Room ID");
          return;
        }

        setStatus("Joining room...");
        socket.emit("join-room", { roomId, isHost });

        if (isHost) {
          try {
            localStream = await navigator.mediaDevices.getUserMedia({
              video: { width: 640, height: 360, frameRate: { max: 15 } },
              audio: true,
            });
            localVideo.srcObject = localStream;

            peerConnection = createPeerConnection();

            localStream.getTracks().forEach((track) => {
              peerConnection.addTrack(track, localStream);
            });

            stopBtn.classList.remove("hidden");
            setStatus("Waiting for viewers to join...");
          } catch (err) {
            alert("Failed to get local media: " + err.message);
            setStatus("Error getting media");
          }
        } else {
          peerConnection = createPeerConnection();
          setStatus("Waiting for host's stream...");
        }
      }

      function stopStream() {
        if (localStream) {
          localStream.getTracks().forEach((track) => track.stop());
          localVideo.srcObject = null;
          localStream = null;
        }
        if (peerConnection) {
          peerConnection.close();
          peerConnection = null;
        }
        socket.emit("stop-stream");
        stopBtn.classList.add("hidden");
        setStatus("Stream stopped");
      }

      function createPeerConnection() {
        const pc = new RTCPeerConnection(config);

        pc.onicecandidate = (event) => {
          if (event.candidate && remoteSocketId) {
            socket.emit("ice-candidate", {
              to: remoteSocketId,
              candidate: event.candidate,
            });
          }
        };

        pc.ontrack = (event) => {
          remoteVideo.srcObject = event.streams[0];
          setStatus("Connected");
        };

        pc.onconnectionstatechange = () => {
          switch (pc.connectionState) {
            case "connected":
              setStatus("Connected");
              break;
            case "disconnected":
            case "failed":
              setStatus("Disconnected. Attempting reconnect...");
              break;
            case "closed":
              setStatus("Connection closed");
              break;
          }
        };

        // Handle renegotiation for host (if needed)
        pc.onnegotiationneeded = async () => {
          if (isHost && remoteSocketId) {
            try {
              const offer = await pc.createOffer();
              await pc.setLocalDescription(offer);
              socket.emit("offer", { to: remoteSocketId, sdp: offer });
            } catch (e) {
              console.error("Negotiation error:", e);
            }
          }
        };

        return pc;
      }

      // ICE candidate queue helper
      async function setRemoteDescriptionAndFlushCandidates(sdp) {
        await peerConnection.setRemoteDescription(
          new RTCSessionDescription(sdp)
        );
        for (const candidate of pendingCandidates) {
          try {
            await peerConnection.addIceCandidate(candidate);
          } catch (e) {
            console.warn("Error adding ICE candidate", e);
          }
        }
        pendingCandidates = [];
      }

      socket.on("existing-users", async (users) => {
        if (isHost || users.length === 0) return;
        remoteSocketId = users[0];
        setStatus("Found host. Preparing connection...");
      });

      socket.on("user-joined", async (id) => {
        if (isHost) {
          remoteSocketId = id;
          try {
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            socket.emit("offer", { to: id, sdp: offer });
          } catch (e) {
            console.error("Offer error:", e);
          }
        }
      });

      socket.on("offer", async (data) => {
        remoteSocketId = data.from;
        try {
          await setRemoteDescriptionAndFlushCandidates(data.sdp);
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);
          socket.emit("answer", { to: data.from, sdp: answer });
        } catch (e) {
          console.error("Answer error:", e);
        }
      });

      socket.on("answer", async (data) => {
        try {
          await peerConnection.setRemoteDescription(
            new RTCSessionDescription(data.sdp)
          );
        } catch (e) {
          console.error("Set remote description error:", e);
        }
      });

      socket.on("ice-candidate", async (data) => {
        try {
          if (peerConnection.remoteDescription) {
            await peerConnection.addIceCandidate(data.candidate);
          } else {
            pendingCandidates.push(data.candidate);
          }
        } catch (e) {
          console.error("Error adding ICE candidate:", e);
        }
      });

      socket.on("stop-stream", () => {
        setStatus("Host stopped streaming.");
        if (remoteVideo.srcObject) {
          remoteVideo.srcObject.getTracks().forEach((t) => t.stop());
          remoteVideo.srcObject = null;
        }
      });

      socket.on("host-disconnected", () => {
        setStatus("Host disconnected.");
        if (remoteVideo.srcObject) {
          remoteVideo.srcObject.getTracks().forEach((t) => t.stop());
          remoteVideo.srcObject = null;
        }
      });

      socket.on("user-left", (id) => {
        if (remoteSocketId === id) {
          setStatus("Viewer disconnected.");
          if (remoteVideo.srcObject) {
            remoteVideo.srcObject.getTracks().forEach((t) => t.stop());
            remoteVideo.srcObject = null;
          }
          remoteSocketId = null;
        }
      });

      socket.on("host-exists", () => {
        alert("Host already exists in this room.");
        setStatus("Host exists, please choose another room.");
      });
    </script>
  </body>
</html>
